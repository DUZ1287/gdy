<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <title>余鑫月，生日快乐！</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            font-family: "Helvetica Neue", "Microsoft Yahei", Arial, sans-serif;
            background: linear-gradient(to bottom, rgb(203,235,219) 0%, rgb(55,148,192) 120%);
            color: #CFEBE4;
            font-size: 18px;
            line-height: 2;
            letter-spacing: 1.2px;
        }
        a { color: #ebf7f4; }
        .canvas { display: block; margin: 0; }
        img#logo {
            width: 128px;
            height: 128px;
            object-fit: cover;
            border-radius: 50%;
            box-shadow: 0 0 40px rgba(63,81,181,0.72);
            border: 3px solid #00a0ff;
            margin: 20px auto;
            display: block;
            transition: transform 1s, box-shadow 1s;
        }
        #logo:hover {
            box-shadow: 0 0 19px #fff;
            transform: rotate(360deg);
        }
        .text {
            position: fixed;
            bottom: 80px;
            text-align: center;
            width: 100%;
            font-weight: bold;
            color: #ed3073;
        }
        .play-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.35);
            color: #fff;
            font-size: 18px;
            z-index: 1000;
            cursor: pointer;
        }
        .play-btn {
            background: rgba(255,255,255,0.15);
            border: 1px solid rgba(255,255,255,0.3);
            padding: 12px 20px;
            border-radius: 8px;
            backdrop-filter: blur(4px);
        }
    </style>
</head>
<body>
    <!-- 更换为仓库中相对路径或公网图片链接，例如 images/avatar.jpg -->
    <img id="logo" src="images/avatar.jpg" alt="头像（请替换为仓库内路径）">

    <canvas class="canvas"></canvas>

    <p class="text">
        世界已经有你
        <br/>
        <span id="span_dt_dt"></span>
    </p>

    <!-- 音频资源：请把音频文件放到仓库并使用相对路径，例如 audio/bgm.mp3 -->
    <audio id="bgm" loop>
        <source src="audio/bgm.mp3" type="audio/mpeg">
        您的浏览器不支持音频播放
    </audio>

    <!-- 首次进入需要用户交互以允许播放的覆盖层 -->
    <div id="playOverlay" class="play-overlay" style="display:flex;">
        <div class="play-btn">点击任意处播放 / 暂停音乐</div>
    </div>

    <script>
    'use strict';
    // 倒计时 / 计时显示
    function show_date_time() {
        // 修改此处为目标生日（美国月/日/年 或 使用 ISO 字符串)
        const BirthDay = new Date("2007-12-24T00:00:00");
        const today = new Date();
        const timeold = today.getTime() - BirthDay.getTime();
        const secondsold = Math.floor(timeold / 1000);
        const msPerDay = 24 * 60 * 60 * 1000;
        const e_daysold = timeold / msPerDay;
        const daysold = Math.floor(e_daysold);
        const e_hrsold = (e_daysold - daysold) * 24;
        const hrsold = Math.floor(e_hrsold);
        const minsold = Math.floor((e_hrsold - hrsold) * 60);
        const seconds = Math.floor(((e_hrsold - hrsold) * 60 - minsold) * 60);
        const span = document.getElementById('span_dt_dt');
        if (span) {
            span.textContent = daysold + "天" + hrsold + "小时" + minsold + "分" + seconds + "秒";
        }
        setTimeout(show_date_time, 1000);
    }
    // 启动计时
    show_date_time();

    // 主动画和粒子系统（基于原始代码，修复若干 bug、变量声明、clone 等）
    (function () {
        const S = {};
        S.init = function () {
            S.Drawing.init('.canvas');
            document.body.classList.add('body--ready');
            // 想说的话（指令串）
            S.UI.simulate("余鑫月|生日快乐|祝你|生活愉快！|#countdown 3|#rectangle 15x15|#circle 12 |#time");
            S.Drawing.loop(function () {
                S.Shape.render();
            });
        };

        S.Drawing = (function () {
            let canvas, context;
            const requestFrame = window.requestAnimationFrame.bind(window);
            return {
                init: function (el) {
                    canvas = document.querySelector(el);
                    if (!canvas) {
                        console.error('Canvas not found:', el);
                        return;
                    }
                    context = canvas.getContext('2d');
                    this.adjustCanvas();
                    window.addEventListener('resize', () => {
                        S.Drawing.adjustCanvas();
                    });
                },
                loop: function (fn) {
                    const render = () => {
                        this.clearFrame();
                        fn();
                        requestFrame(render);
                    };
                    render();
                },
                adjustCanvas: function () {
                    if (!canvas) return;
                    canvas.width = window.innerWidth - 100;
                    canvas.height = window.innerHeight - 30;
                },
                clearFrame: function () {
                    if (!context) return;
                    context.clearRect(0, 0, canvas.width, canvas.height);
                },
                getArea: function () {
                    return { w: canvas.width, h: canvas.height };
                },
                drawCircle: function (p, c) {
                    if (!context) return;
                    context.fillStyle = c.render();
                    context.beginPath();
                    context.arc(p.x, p.y, p.z, 0, 2 * Math.PI, true);
                    context.closePath();
                    context.fill();
                }
            };
        }());

        // UI parser and sequencer (未改动逻辑，仅整理作用域)
        S.UI = (function () {
            let interval, currentAction, timeVar;
            const maxShapeSize = 30;
            let sequence = [];
            const cmd = '#';
            function formatTime(date) {
                let h = date.getHours(), m = date.getMinutes();
                m = m < 10 ? '0' + m : m;
                return h + ':' + m;
            }
            function getValue(value) { return value && value.split(' ')[1]; }
            function getAction(value) { value = value && value.split(' ')[0]; return value && value[0] === cmd && value.substring(1); }
            function timedAction(fn, delay, max, reverse) {
                clearInterval(interval);
                currentAction = reverse ? max : 1;
                fn(currentAction);
                if (!max || (!reverse && currentAction < max) || (reverse && currentAction > 0)) {
                    interval = setInterval(function () {
                        currentAction = reverse ? currentAction - 1 : currentAction + 1;
                        fn(currentAction);
                        if ((!reverse && max && currentAction === max) || (reverse && currentAction === 0)) {
                            clearInterval(interval);
                        }
                    }, delay);
                }
            }
            function performAction(value) {
                sequence = typeof (value) === 'object' ? value : sequence.concat(value.split('|'));
                timedAction(function (index) {
                    const current = sequence.shift();
                    const action = getAction(current);
                    let val = getValue(current);
                    switch (action) {
                        case 'countdown':
                            val = parseInt(val) || 10;
                            val = val > 0 ? val : 10;
                            timedAction(function (idx) {
                                if (idx === 0) {
                                    if (sequence.length === 0) {
                                        S.Shape.switchShape(S.ShapeBuilder.letter(''));
                                    } else {
                                        performAction(sequence);
                                    }
                                } else {
                                    S.Shape.switchShape(S.ShapeBuilder.letter(idx), true);
                                }
                            }, 1000, val, true);
                            break;
                        case 'rectangle':
                            val = val && val.split('x');
                            val = (val && val.length === 2) ? val : [maxShapeSize, Math.floor(maxShapeSize / 2)];
                            S.Shape.switchShape(S.ShapeBuilder.rectangle(Math.min(maxShapeSize, parseInt(val[0])), Math.min(maxShapeSize, parseInt(val[1]))));
                            break;
                        case 'circle':
                            val = parseInt(val) || maxShapeSize;
                            val = Math.min(val, maxShapeSize);
                            S.Shape.switchShape(S.ShapeBuilder.circle(val));
                            break;
                        case 'time':
                            let t = formatTime(new Date());
                            if (sequence.length > 0) {
                                S.Shape.switchShape(S.ShapeBuilder.letter(t));
                            } else {
                                timedAction(function () {
                                    t = formatTime(new Date());
                                    if (t !== timeVar) {
                                        timeVar = t;
                                        S.Shape.switchShape(S.ShapeBuilder.letter(timeVar));
                                    }
                                }, 1000);
                            }
                            break;
                        default:
                            S.Shape.switchShape(S.ShapeBuilder.letter(current[0] === cmd ? 'HacPai' : current));
                    }
                }, 2000, sequence.length);
            }
            return {
                simulate: function (action) {
                    performAction(action);
                }
            };
        }());

        // 基本数据结构
        S.Point = function (args) {
            this.x = args.x || 0;
            this.y = args.y || 0;
            this.z = args.z || 0;
            this.a = args.a || 1;
            this.h = args.h || 0;
        };
        S.Color = function (r, g, b, a) {
            this.r = r; this.g = g; this.b = b; this.a = a;
        };
        S.Color.prototype = {
            render: function () {
                return 'rgba(' + this.r + ',' + this.g + ',' + this.b + ',' + this.a + ')';
            }
        };

        // 单个粒子点
        S.Dot = function (x, y) {
            this.p = new S.Point({ x: x, y: y, z: 5, a: 1, h: 0 });
            this.e = 0.07;
            this.s = true;
            this.c = new S.Color(255, 255, 255, this.p.a);
            this.t = this.clone();
            this.q = [];
        };
        S.Dot.prototype = {
            clone: function () {
                // 修复 clone 使用 this.p 的数据
                return new S.Point({
                    x: this.p.x,
                    y: this.p.y,
                    z: this.p.z,
                    a: this.p.a,
                    h: this.p.h
                });
            },
            _draw: function () {
                this.c.a = this.p.a;
                S.Drawing.drawCircle(this.p, this.c);
            },
            _moveTowards: function (n) {
                const details = this.distanceTo(n, true);
                const dx = details[0], dy = details[1], d = details[2];
                const e = this.e * d;
                if (this.p.h === -1) {
                    this.p.x = n.x;
                    this.p.y = n.y;
                    return true;
                }
                if (d > 1) {
                    this.p.x -= ((dx / d) * e);
                    this.p.y -= ((dy / d) * e);
                } else {
                    if (this.p.h > 0) {
                        this.p.h--;
                    } else {
                        return true;
                    }
                }
                return false;
            },
            _update: function () {
                if (this._moveTowards(this.t)) {
                    const p = this.q.shift();
                    if (p) {
                        this.t.x = (p.x !== undefined) ? p.x : this.p.x;
                        this.t.y = (p.y !== undefined) ? p.y : this.p.y;
                        this.t.z = (p.z !== undefined) ? p.z : this.p.z;
                        this.t.a = (p.a !== undefined) ? p.a : this.p.a;
                        this.p.h = p.h || 0;
                    } else {
                        if (this.s) {
                            this.p.x -= Math.sin(Math.random() * 3.142);
                            this.p.y -= Math.sin(Math.random() * 3.142);
                        } else {
                            this.move(new S.Point({
                                x: this.p.x + (Math.random() * 50) - 25,
                                y: this.p.y + (Math.random() * 50) - 25
                            }));
                        }
                    }
                }
                let d = this.p.a - this.t.a;
                this.p.a = Math.max(0.1, this.p.a - (d * 0.05));
                d = this.p.z - this.t.z;
                this.p.z = Math.max(1, this.p.z - (d * 0.05));
            },
            distanceTo: function (n, details) {
                const dx = this.p.x - n.x, dy = this.p.y - n.y;
                const d = Math.sqrt(dx * dx + dy * dy);
                return details ? [dx, dy, d] : d;
            },
            move: function (p, avoidStatic) {
                if (!avoidStatic || (avoidStatic && this.distanceTo(p) > 1)) {
                    this.q.push(p);
                }
            },
            render: function () {
                this._update();
                this._draw();
            }
        };

        // 形状构建器
        S.ShapeBuilder = (function () {
            const gap = 13;
            const shapeCanvas = document.createElement('canvas');
            const shapeContext = shapeCanvas.getContext('2d');
            let fontSize = 500;
            const fontFamily = 'Avenir, Helvetica Neue, Helvetica, Arial, sans-serif';

            function fit() {
                shapeCanvas.width = Math.floor(window.innerWidth / gap) * gap;
                shapeCanvas.height = Math.floor(window.innerHeight / gap) * gap;
                shapeContext.fillStyle = 'red';
                shapeContext.textBaseline = 'middle';
                shapeContext.textAlign = 'center';
            }
            function processCanvas() {
                const pixels = shapeContext.getImageData(0, 0, shapeCanvas.width, shapeCanvas.height).data;
                const dots = [];
                let x = 0, y = 0, fx = shapeCanvas.width, fy = shapeCanvas.height, w = 0, h = 0;
                for (let p = 0; p < pixels.length; p += (4 * gap)) {
                    if (pixels[p + 3] > 0) {
                        dots.push(new S.Point({ x: x, y: y }));
                        w = x > w ? x : w;
                        h = y > h ? y : h;
                        fx = x < fx ? x : fx;
                        fy = y < fy ? y : fy;
                    }
                    x += gap;
                    if (x >= shapeCanvas.width) {
                        x = 0;
                        y += gap;
                        p += gap * 4 * shapeCanvas.width;
                    }
                }
                return { dots: dots, w: w + fx, h: h + fy };
            }
            function setFontSize(s) {
                shapeContext.font = 'bold ' + s + 'px ' + fontFamily;
            }
            function isNumber(n) {
                return !isNaN(parseFloat(n)) && isFinite(n);
            }
            function init() {
                fit();
                window.addEventListener('resize', fit);
            }
            init();

            return {
                imageFile: function (url, callback) {
                    const image = new Image();
                    const a = S.Drawing.getArea();
                    image.onload = function () {
                        shapeContext.clearRect(0, 0, shapeCanvas.width, shapeCanvas.height);
                        shapeContext.drawImage(this, 0, 0, a.h * 0.6, a.h * 0.6);
                        callback(processCanvas());
                    };
                    image.onerror = function () {
                        callback(S.ShapeBuilder.letter('What?'));
                    };
                    image.src = url;
                },
                circle: function (d) {
                    const r = Math.max(0, d) / 2;
                    shapeContext.clearRect(0, 0, shapeCanvas.width, shapeCanvas.height);
                    shapeContext.beginPath();
                    shapeContext.arc(r * gap, r * gap, r * gap, 0, 2 * Math.PI, false);
                    shapeContext.fill();
                    shapeContext.closePath();
                    return processCanvas();
                },
                letter: function (l) {
                    let s = 0;
                    setFontSize(fontSize);
                    s = Math.min(fontSize,
                        (shapeCanvas.width / shapeContext.measureText(l).width) * 0.8 * fontSize,
                        (shapeCanvas.height / fontSize) * (isNumber(l) ? 1 : 0.45) * fontSize);
                    setFontSize(s);
                    shapeContext.clearRect(0, 0, shapeCanvas.width, shapeCanvas.height);
                    shapeContext.fillText(l, shapeCanvas.width / 2, shapeCanvas.height / 2);
                    return processCanvas();
                },
                rectangle: function (w, h) {
                    const dots = [];
                    const width = gap * w, height = gap * h;
                    for (let y = 0; y < height; y += gap) {
                        for (let x = 0; x < width; x += gap) {
                            dots.push(new S.Point({ x: x, y: y }));
                        }
                    }
                    return { dots: dots, w: width, h: height };
                }
            };
        }());

        // S.Shape 渲染引擎
        S.Shape = (function () {
            const dots = [];
            let width = 0, height = 0, cx = 0, cy = 0;
            function compensate() {
                const a = S.Drawing.getArea();
                cx = a.w / 2 - width / 2;
                cy = a.h / 2 - height / 2;
            }
            return {
                shuffleIdle: function () {
                    const a = S.Drawing.getArea();
                    for (let d = 0; d < dots.length; d++) {
                        if (!dots[d].s) {
                            dots[d].move({ x: Math.random() * a.w, y: Math.random() * a.h });
                        }
                    }
                },
                switchShape: function (n, fast) {
                    const a = S.Drawing.getArea();
                    width = n.w; height = n.h;
                    compensate();
                    if (n.dots.length > dots.length) {
                        const size = n.dots.length - dots.length;
                        for (let d = 1; d <= size; d++) {
                            dots.push(new S.Dot(a.w / 2, a.h / 2));
                        }
                    }
                    let dIdx = 0;
                    while (n.dots.length > 0) {
                        const i = Math.floor(Math.random() * n.dots.length);
                        dots[dIdx].e = fast ? 0.25 : (dots[dIdx].s ? 0.14 : 0.11);
                        if (dots[dIdx].s) {
                            dots[dIdx].move(new S.Point({ z: Math.random() * 20 + 10, a: Math.random(), h: 18 }));
                        } else {
                            dots[dIdx].move(new S.Point({ z: Math.random() * 5 + 5, h: fast ? 18 : 30 }));
                        }
                        dots[dIdx].s = true;
                        dots[dIdx].move(new S.Point({
                            x: n.dots[i].x + cx,
                            y: n.dots[i].y + cy,
                            a: 1,
                            z: 5,
                            h: 0
                        }));
                        n.dots = n.dots.slice(0, i).concat(n.dots.slice(i + 1));
                        dIdx++;
                    }
                    for (let i = dIdx; i < dots.length; i++) {
                        if (dots[i].s) {
                            dots[i].move(new S.Point({ z: Math.random() * 20 + 10, a: Math.random(), h: 20 }));
                            dots[i].s = false;
                            dots[i].e = 0.04;
                            dots[i].move(new S.Point({
                                x: Math.random() * a.w,
                                y: Math.random() * a.h,
                                a: 0.3,
                                z: Math.random() * 4,
                                h: 0
                            }));
                        }
                    }
                },
                render: function () {
                    for (let d = 0; d < dots.length; d++) {
                        dots[d].render();
                    }
                }
            };
        }());

        // 等 DOM 就绪再初始化
        document.addEventListener('DOMContentLoaded', function () {
            S.init();
        });

        // 导出到全局以便调试（可选）
        window.S = S;
    })();

    // 音频交互逻辑：点击任意处播放/暂停并在第一次点击后隐藏覆盖层
    (function () {
        const bgm = document.getElementById('bgm');
        const overlay = document.getElementById('playOverlay');

        function togglePlay() {
            if (!bgm) return;
            if (bgm.paused) {
                bgm.play().catch((e) => {
                    console.warn('播放失败：', e);
                });
            } else {
                bgm.pause();
            }
        }

        // 任何点击都触发第一次播放尝试并隐藏 overlay（即使播放失败也隐藏）
        overlay.addEventListener('click', function () {
            togglePlay();
            overlay.style.display = 'none';
        });

        // 之后任意页面点击切换播放状态（去掉 overlay 后）
        document.body.addEventListener('click', function (e) {
            // 如果 overlay 仍在，首次点击由 overlay 处理
            if (overlay && overlay.style.display !== 'none') return;
            // 忽略点击到控制元素等（如果你有其他交互可排除）
            if (e.target && (e.target.tagName === 'BUTTON' || e.target.tagName === 'A')) return;
            togglePlay();
        }, false);

        // 预加载音频（尝试）
        window.addEventListener('load', () => {
            if (!bgm) return;
            bgm.muted = true;
            bgm.play().then(() => bgm.pause()).catch(()=>{/* ignore */});
            bgm.muted = false;
        });
    })();
    </script>
</body>
</html>